---
# Prerequisites:
## Modify the inventory file to reflect your environment
## The user must have password-less sudo access
## The user must have password-less ssh access to the remote hosts
## You need a user to push to your remote registry

- name: Push a local set of oc-mirror packed TAR files to a remote registry
  hosts: localhost
  gather_facts: true
  become: true

  tasks:
    - name: Make sure that the root user has /usr/local/bin in its PATH
      block:
        - name: Check if /usr/local/bin is already defined
          ansible.builtin.lineinfile:
            state: absent
            path: "/root/.bashrc"
            regexp: "/usr/local/bin"
          check_mode: true
          changed_when: false # This just makes things look prettier in the logs
          register: path_check

        - name: Define /usr/local/bin if undefined
          ansible.builtin.lineinfile:
            state: present
            path: "/root/.bashrc"
            line: "export PATH=$PATH:/usr/local/bin"
          when: path_check.found == 0

    - name: Get the path to oc, discount double check
      ansible.builtin.command:
        cmd: which oc
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin"
      register: oc_path
      changed_when: false

    - name: Create the Container Registry Config directory
      ansible.builtin.file:
        path: "{{ target_registry_auth_path }}"
        state: directory
        owner: "{{ target_registry_auth_path_user }}"
        group: "{{ target_registry_auth_path_group }}"
        mode: 0700

    - name: Create the authentication file for the registry
      ansible.builtin.template:
        src: templates/registry_auth.json.j2
        dest: "{{ target_registry_auth_path }}/config.json"
        mode: 0600


    - name: Generate Basic Auth Token for each registry
      ansible.builtin.set_fact:
        auth_token: "{{ (item.username + ':' + item.password) | b64encode }}"
      when: item.registry_type == "harbor"
      loop: "{{ registries }}"
      loop_control:
        loop_var: item

    - name: Create Harbor Projects
      ansible.builtin.uri:
        url: "https://{{ item.server }}/api/v2.0/projects"
        method: POST
        headers:
          Authorization: "Basic {{ auth_token }}"
          Content-Type: "application/json"
        body_format: json
        status_code: 201
        validate_certs: no
        body: |
          {
            "project_name": "{{ item.path }}",
            "metadata": {
              "public": "true"
            },
            "storage_limit": -1,
            "registry_id": null
          }
      when: item.registry_type == "harbor"
      ignore_errors: true
      loop: "{{ registries }}"
      loop_control:
        loop_var: item

    - name: Push the mirror to the remote registry
      delegate_to: localhost # Ensure oc mirror runs on the control node
      ansible.builtin.shell:
        cmd: |-
          {{ oc_path.stdout }} mirror --from={{ source_mirror_path }}/{{ mirror_tar_file }} docker://{{ registry.server }}/{{ registry.path | default(omit) }} --dest-skip-tls
      loop: "{{ registries }}"
      loop_control:
        loop_var: registry
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin"
      register: oc_mirror_output

    - name: Get remote checksums (Quay)
      ansible.builtin.uri:
        url: "https://{{ registry.server }}:8443/api/v1/repository/{{ registry.path | default(omit) }}/{{ mirror_tar_file | basename | replace('.tar', '') }}/tag"
        method: GET
        status_code: 200
        return_content: yes
        validate_certs: no
      register: quay_remote_checksums
      when: registry.registry_type == "quay"
      loop: "{{ registries }}"
      loop_control:
        loop_var: registry

    - name: Verify checksums (Quay)
      ansible.builtin.fail:
        msg: "Checksum verification failed for {{ registry.server }}/{{ registry.path | default(omit) }}/{{ mirror_tar_file | basename | replace('.tar', '') }}"
      when: >
        registry.registry_type == "quay" and
        local_checksums.stdout | regex_search('(\\w+)\\s+{{ source_mirror_path }}/{{ mirror_tar_file }}', '\\1') != (quay_remote_checksums.json | from_json)[0].manifest_digest | regex_search('sha256:(\\w+)', '\\1')
      loop: "{{ registries }}"
      loop_control:
        loop_var: registry

    - name: Display oc mirror results
      ansible.builtin.debug:
        var: oc_mirror_output

    - name: Run oc mirror with --manifests-only if no output available
      ansible.builtin.shell:
        cmd: |-
          {{ oc_path.stdout }} mirror --from={{ source_mirror_path }}/{{ mirror_tar_file }} docker://{{ registry.server }}/{{ registry.path | default(omit) }} --manifests-only
      when: oc_mirror_output.stdout_lines is not defined
      loop: "{{ registries }}"
      loop_control:
        loop_var: registry
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin"
      register: oc_mirror_manifests_output
      args:
        chdir: "{{ source_mirror_path }}"

    - name: Debug oc_mirror_output
      ansible.builtin.debug:
        msg: "{{ oc_mirror_output }}"

    - name: Set fact for oc_mirror_manifests_output
      ansible.builtin.set_fact:
        oc_mirror_manifests_output: "{{ oc_mirror_manifests_output if oc_mirror_manifests_output.stdout is defined else oc_mirror_output }}"

    - name: Set default mirror results path
      ansible.builtin.set_fact:
        oc_mirror_results_path: "{{ source_mirror_path }}/oc-mirror-workspace/results-{{ lookup('pipe', 'date +%s') }}"
      when: oc_mirror_manifests_output.results[0].stdout is not regex('Writing ICSP manifests to')

    - name: Extract mirror results path from output if available
      ansible.builtin.set_fact:
        oc_mirror_results_path: "{{ oc_mirror_manifests_output.results[0].stdout | regex_search('Writing ICSP manifests to (.+)', '\\1') | first }}"
      when: oc_mirror_manifests_output.results[0].stdout is regex('Writing ICSP manifests to')

    - name: Create mirror results directory if it doesn't exist
      ansible.builtin.file:
        path: "{{ oc_mirror_results_path }}"
        state: directory
        mode: '0755'

    - name: Display the path to the mirror results
      ansible.builtin.debug:
        msg: "Results path: {{ oc_mirror_results_path }}"

    - name: Check if the expected files are created
      ansible.builtin.find:
        paths: "{{ oc_mirror_results_path }}"
        patterns: 'updateService.yaml'
      register: update_service_file_check

    - name: Display file check results
      ansible.builtin.debug:
        msg: "File check results: {{ update_service_file_check }}"

    - name: Check if updateService.yaml exists
      ansible.builtin.stat:
        path: "{{ oc_mirror_results_path }}/updateService.yaml"
      register: update_service_file

    - name: Read in the updateService.yaml file
      ansible.builtin.slurp:
        src: "{{ oc_mirror_results_path }}/updateService.yaml"
      register: update_service_yaml
      when: update_service_file.stat.exists

    - name: Set empty fact if file doesn't exist
      ansible.builtin.set_fact:
        update_service_yaml: {'content': ''}
      when: not update_service_file.stat.exists

    - name: Check if imageContentSourcePolicy.yaml exists
      ansible.builtin.stat:
        path: "{{ oc_mirror_results_path }}/imageContentSourcePolicy.yaml"
      register: image_content_source_policy_file

    - name: Read in the imageContentSourcePolicy.yaml file
      ansible.builtin.slurp:
        src: "{{ oc_mirror_results_path }}/imageContentSourcePolicy.yaml"
      register: image_content_source_policy_yaml
      when: image_content_source_policy_file.stat.exists

    - name: Set empty fact if imageContentSourcePolicy file doesn't exist
      ansible.builtin.set_fact:
        image_content_source_policy_yaml: {'content': ''}
      when: not image_content_source_policy_file.stat.exists

    - name: Read in the imageContentSourcePolicy.yaml file
      ansible.builtin.slurp:
        src: "{{ oc_mirror_results_path }}/imageContentSourcePolicy.yaml"
      register: image_content_source_policy_yaml

    - name: Find all the catalogSource prefixed files
      ansible.builtin.find:
        paths: "{{ oc_mirror_results_path }}"
        patterns: 'catalogSource*'
      register: catalog_source_files

    - name: Read in all the catalog_source_files
      ansible.builtin.slurp:
        src: "{{ yaml_item.path }}"
      loop: "{{ catalog_source_files.files }}"
      loop_control:
        loop_var: yaml_item
      register: catalog_source_yaml

    - name: Display the updateService YAML as JSON
      ansible.builtin.debug:
        msg: "{{ yaml_item | from_yaml }}"
      loop: "{{ [update_service_yaml.content | b64decode] }}"
      loop_control:
        loop_var: yaml_item

    - name: Display the imageContentSourcePolicy YAML objects as JSON
      ansible.builtin.debug:
        msg: "{{ yaml_item | from_yaml }}"
      loop: "{{ image_content_source_policy_yaml.content | b64decode | split('---') }}"
      loop_control:
        loop_var: yaml_item

    - name: Display the catalogSource YAML as JSON
      ansible.builtin.debug:
        msg: "{{ yaml_item.content | b64decode | from_yaml }}"
      loop: "{{ catalog_source_yaml.results }}"
      loop_control:
        loop_var: yaml_item
        label: "{{ yaml_item.source }}"

    - name: Show user location of the mirror results
      ansible.builtin.debug:
        msg: "Mirror results are located at {{ oc_mirror_results_path }}"
